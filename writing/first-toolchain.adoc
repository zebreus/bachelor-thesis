= Running Rust on an FPGA

== Introduction: Begin by introducing the topic of High-level synthesis (HLS) and its importance in the field of FPGA programming. Explain why you've chosen to focus on Rust as the programming language for HLS.

== What is High-level synthesis (HLS): Describe what HLS is, how it differs from traditional FPGA programming, and the benefits of using HLS.

Usually one would write code for an FPGA in a hardware description language (HDL) such as Verilog or VHDL. However, this is a very low-level language, and it is difficult to write code in it. This is where HLS comes in.

HLS is a process that allows developers to write high-level code, such as C/C++ or Rust code, and then use a toolchain to automatically convert that code into RTL (register-transfer level) code, which can be used to program an FPGA. This is different from traditional FPGA programming, where developers write RTL code directly.


== Why Rust for HLS: Explain why Rust is a good choice for HLS and how its features such as memory safety and thread safety align with the requirements of HLS.

== Building the toolchain: Describe the process of building the toolchain for HLS from Rust. Explain the different components of the toolchain, such as the Rust-to-C\++ translator and the C\++-to-RTL synthesis tool.

== First prototype: Describe the first prototype of your toolchain and the results you achieved. Show some examples of code written in Rust and the corresponding RTL generated by your toolchain.

== Future work: Discuss future work for your toolchain. This can include additional features or improvements that you plan to make.

== Conclusion: Summarize the key points of the blog post and explain why HLS is an important technology for FPGA programming.

== References: Include any references you used while writing the blog post.


== Writing Code that synthesizes well

Bambu is build to synthesize C/C++ code.

The example for a function that finds that minimum or maximum in an array is a good example of how to write code that synthesizes well. It is just very C-like code, that mutates its inputs and has a interface that is not very Rust-like.

[source,cpp]
----
void min_max_cpp(int* input, int num_elements, int* out_max, int* out_min)
{
   int local_max = input[0];
   int local_min = input[0];
   int i = 0;
   for(i = 0; i < num_elements; i++)
   {
      if(input[i] > local_max)
      {
         local_max = input[i];
      }
      if(input[i] < local_min)
      {
         local_min = input[i];
      }
   }
   *out_max = local_max;
   *out_min = local_min;
}
----

The function takes a pointer to an array of integers, the number of elements in the array, and two pointers to integers. The function will find the minimum and maximum in the array and write them to the memory locations pointed to by `out_max` and `out_min`.

We synthesize the function using bambu and use bambus integrated test runner to test the function against some testcases. Later we will use the same testcases for the Rust version of the function. The optimization level is set to `-O2` for now.

.Testcases:
* input=[0,1,2,3,4] num_elements=5 out_max=0 out_min=3
* input=[15,10,5] num_elements=3 out_max=15 out_min=5 

The tests are executed using verilator, so they are not completly representative of the actual hardware, because Verilator does not simulate timings beyond the clock cycles. I think comparing clock cycles is a good enough approximation for now.

.Output of synthesizing the cpp function
[%collapsible]
====
[source,console]
----
$ nix run github:zebreus/bachelor-thesis#bambu-appimage -- min_max_cpp.c --top-fname=min_max --compiler=I386_CLANG12 --generate-tb=testbench.xml --simulate --simulator=VERILATOR -O2
  Module binding information for function min_max_cpp:
    Number of modules instantiated: 112
    Number of performance conflicts: 12
    Estimated resources area (no Muxes and address logic): 1034
    Estimated area of MUX21: 72
    Total estimated area: 1106
    Estimated number of DSPs: 0
  Time to perform module binding: 0.00 seconds

  Total number of flip-flops in function min_max_cpp: 1062
  Total cycles             : 22 cycles
  Number of executions     : 2
  Average execution        : 11 cycles
----
====

Translating this to Rust is not very difficult. We need to access the input array in rust using `array.get_unchecked(i)` instead of `array[i]`, because the latter is always bounds checked. If we used the checked version, our code could panic, which is not synthesizable. Finally, we need to mark the function as `#[no_mangle]`, so that the function name is preserved.

[source,rust]
----
#[no_mangle]
pub unsafe extern "C" fn min_max_rust(
    input: *mut i32,
    num_elements: i32,
    out_max: &mut i32,
    out_min: &mut i32,
) {
    let mut local_max = *input.offset(0);
    let mut local_min = *input.offset(0);
    for i in 0..num_elements {
        if *input.offset(i as isize) > local_max {
            local_max = *input.offset(i as isize);
        }
        if *input.offset(i as isize) < local_min {
            local_min = *input.offset(i as isize);
        }
    }
    *out_max = local_max;
    *out_min = local_min;
}
----

If we compile that code to LLVM IR and try to use bambu with it we get an error that `llvm.vector.reduce.smax.v4i32` is not supported. Bambu does not support llvm vector instructions. They probably get inserted by the https://llvm.org/docs/Vectorizers.html#the-loop-vectorizer[LLVM Loop Vectorizer]. We can disable that vectorization pass by passing `-C no-vectorize-loops` to rustc.


By default the Rust compiler generates code that unwinds the stack on panic. The generated LLVM IR also has a exception handling personality function added to every function in LLVM IR. Both are not synthesizable. We tell the compiler to instead termintate the program on panic by passing `-C panic=abort` to rustc. Terminating the program is also not synthesizable, but as long as we dont panic, it is fine.

We also need to disable overflow checks, because they will generate panics. We can do that by passing `-C overflow-checks=off` to rustc.

Finally, we need to pass `-C target-cpu=generic --target=unknown-unknown-unknown` to rustc, because we dont target the host CPU.

It is probably good idea to tell the rust compiler that we are not targeting a specific cpu architecture by passing `-C target-cpu=generic`.

The final command to compile the rust code to LLVM IR is:

----
rustc --emit=llvm-ir --crate-type=lib src/min_max_rust.rs -o min_max_rust.ll -C opt-level=0 -C overflow-checks=off -C no-vectorize-loops -C target-cpu=generic -C panic=abort
----

Bambu fails to synthesize the rust code if optimizations are disabled. Enabling at least some level of optimization in rustc or enableing a level higher than 1 in bambu fixes the problem. We will set the optimization level to `-O2` in bambu, because that should have a smaller impact on the results than enabling optimizations in rustc.

.Output of synthesizing the rust function
[%collapsible]
====
[source,console]
----
$ nix run github:zebreus/bachelor-thesis#bambu-appimage -- min_max_rust.ll --top-fname=min_max_rust --compiler=I386_CLANG12 --generate-tb=testbench_llvm.xml --simulate --simulator=VERILATOR -O2
  Module binding information for function min_max_rust:
    Number of modules instantiated: 112
    Number of performance conflicts: 12
    Estimated resources area (no Muxes and address logic): 1034
    Estimated area of MUX21: 72
    Total estimated area: 1106
    Estimated number of DSPs: 0
  Time to perform module binding: 0.00 seconds

  Total number of flip-flops in function min_max_rust: 1062
  Total cycles             : 22 cycles
  Number of executions     : 2
  Average execution        : 11 cycles
----
====

While taking up roughly the same amount of resources, the rust version need roughly 2 times less cycles to execute. For now I dont know why that is the case. I would have assumed that the rust version would be slower, because the cpp version had optimizations enabled during compilation and synthesis, while the rust version did not.

Lets try the cpp and the rust version with optimizations set to the maximum level.


.CPP with clang and `-O5`
[%collapsible]
====
[source,console]
----
$ nix run github:zebreus/bachelor-thesis#bambu-appimage -- min_max_cpp.cpp --top-fname=min_max_cpp --compiler=I386_CLANG12 --generate-tb=testbench.xml --simulate --simulator=VERILATOR -O5
  Module binding information for function min_max_cpp:
    Number of modules instantiated: 112
    Number of performance conflicts: 12
    Estimated resources area (no Muxes and address logic): 1034
    Estimated area of MUX21: 72
    Total estimated area: 1106
    Estimated number of DSPs: 0
  Time to perform module binding: 0.00 seconds

  Total number of flip-flops in function min_max_cpp: 1062
  Total cycles             : 22 cycles
  Number of executions     : 2
  Average execution        : 11 cycles
----
====

.CPP with clang and `-Os`
[%collapsible]
====
[source,console]
----
$ nix run github:zebreus/bachelor-thesis#bambu-appimage -- min_max_cpp.cpp --top-fname=min_max_cpp --compiler=I386_CLANG12 --generate-tb=testbench.xml --simulate --simulator=VERILATOR -O5
  Module binding information for function min_max_cpp:
    Number of modules instantiated: 25
    Number of performance conflicts: 0
    Estimated resources area (no Muxes and address logic): 208
    Estimated area of MUX21: 70
    Total estimated area: 278
    Estimated number of DSPs: 0
  Time to perform module binding: 0.00 seconds

  Total number of flip-flops in function min_max_cpp: 226
  Total cycles             : 22 cycles
  Number of executions     : 2
  Average execution        : 11 cycles
----
====

.CPP with gcc and `-O5`
[%collapsible]
====
[source,console]
----
$ nix run github:zebreus/bachelor-thesis#bambu-appimage -- min_max_cpp.cpp --top-fname=min_max_cpp --compiler=I386_GCC7 --generate-tb=testbench.xml --simulate --simulator=VERILATOR -O5
  Module binding information for function min_max_cpp:
    Number of modules instantiated: 21
    Number of performance conflicts: 0
    Estimated resources area (no Muxes and address logic): 197
    Estimated area of MUX21: 70
    Total estimated area: 267
    Estimated number of DSPs: 0
  Time to perform module binding: 0.00 seconds

  Total number of flip-flops in function min_max_cpp: 163
  Total cycles             : 24 cycles
  Number of executions     : 2
  Average execution        : 12 cycles
----
====

.CPP with gcc and `-Os`
[%collapsible]
====
[source,console]
----
$ nix run github:zebreus/bachelor-thesis#bambu-appimage -- min_max_cpp.cpp --top-fname=min_max_cpp --compiler=I386_GCC7 --generate-tb=testbench.xml --simulate --simulator=VERILATOR -Os
  Module binding information for function min_max_cpp:
    Number of modules instantiated: 15
    Number of performance conflicts: 0
    Estimated resources area (no Muxes and address logic): 172
    Estimated area of MUX21: 70
    Total estimated area: 242
    Estimated number of DSPs: 0
  Time to perform module binding: 0.00 seconds

  Total number of flip-flops in function min_max_cpp: 192
  Total cycles             : 28 cycles
  Number of executions     : 2
  Average execution        : 14 cycles
----
====

.Rust with `-O5` and `-C opt-level=3`
[%collapsible]
====
[source,console]
----
$ rustc --emit=llvm-ir --crate-type=lib src/min_max_rust.rs -o min_max_rust.ll -C overflow-checks=off -C no-vectorize-loops -C target-cpu=generic -C panic=abort -C opt-level=3
$ nix run github:zebreus/bachelor-thesis#bambu-appimage -- min_max_rust.ll --top-fname=min_max_rust --compiler=I386_CLANG12 --generate-tb=testbench_llvm.xml --simulate --simulator=VERILATOR -O5
  Module binding information for function min_max_rust:
    Number of modules instantiated: 116
    Number of performance conflicts: 12
    Estimated resources area (no Muxes and address logic): 1190
    Estimated area of MUX21: 72
    Total estimated area: 1262
    Estimated number of DSPs: 0
  Time to perform module binding: 0.01 seconds

  Total number of flip-flops in function min_max_rust: 1284
  Total cycles             : 20 cycles
  Number of executions     : 2
  Average execution        : 10 cycles
----

When using rust optimization levels _3_ or _2_ the bambu opt level does not matter for this example.
====

.Rust with `-Os` and `-C opt-level=s`
[%collapsible]
====
[source,console]
----
$ rustc --emit=llvm-ir --crate-type=lib src/min_max_rust.rs -o min_max_rust.ll -C overflow-checks=off -C no-vectorize-loops -C target-cpu=generic -C panic=abort -C opt-level=s
$ nix run github:zebreus/bachelor-thesis#bambu-appimage -- min_max_rust.ll --top-fname=min_max_rust --compiler=I386_CLANG12 --generate-tb=testbench_llvm.xml --simulate --simulator=VERILATOR -Os
  Module binding information for function min_max_rust:
    Number of modules instantiated: 28
    Number of performance conflicts: 0
    Estimated resources area (no Muxes and address logic): 238
    Estimated area of MUX21: 68
    Total estimated area: 306
    Estimated number of DSPs: 0
  Time to perform module binding: 0.00 seconds

  Total number of flip-flops in function min_max_rust: 290
  Total cycles             : 20 cycles
  Number of executions     : 2
  Average execution        : 10 cycles
----

When using rust optimization levels _s_ the bambu opt level does not matter for this example.
====

// fn min_max(input: &[i32], num_elements: usize, out_max: &mut i32, out_min: &mut i32)
// {
//     let mut local_max = input[0];
//     let mut local_min = input[0];
//     for i in 1..num_elements
//     {
//         if input[i] > local_max
//         {
//             local_max = input[i];
//         }
//         if input[i] < local_min
//         {
//             local_min = input[i];
//         }
//     }
//     out_max = local_max;
//     out_min = local_min;

// }


A more idiomatic Rust version of the same function using slices and iterators.

[source,rust]
----
#[repr(C)]
pub struct MinMax {
    pub max: i32,
    pub min: i32,
}

#[no_mangle]
pub unsafe extern "C" fn min_max_rust_idiomatic(input: *mut i32, num_elements: i32) -> MinMax {
    let slice = std::slice::from_raw_parts_mut(input, num_elements as usize);

    slice.iter().fold(MinMax { max: 0, min: 0 }, |mut acc, &x| {
        if x > acc.max {
            acc.max = x;
        }
        if x < acc.min {
            acc.min = x;
        }
        acc
    });
}
----

.Idiomatic rust with `-Os` and `-C opt-level=s`
[%collapsible]
====
[source,console]
----
$ rustc --emit=llvm-ir --crate-type=lib src/min_max_rust_idiomatic.rs -o min_max_rust_idiomatic.ll -C overflow-checks=off -C no-vectorize-loops -C target-cpu=generic -C panic=abort -C opt-level=s
$ nix run github:zebreus/bachelor-thesis#bambu-appimage -- min_max_rust_idiomatic.ll --top-fname=min_max_rust_idiomatic --compiler=I386_CLANG12 --generate-tb=testbench_llvm.xml --simulate --simulator=VERILATOR -Os
  Module binding information for function min_max_rust_idiomatic:
    Number of modules instantiated: 27
    Number of performance conflicts: 0
    Estimated resources area (no Muxes and address logic): 202
    Estimated area of MUX21: 0
    Total estimated area: 202
    Estimated number of DSPs: 0
  Time to perform module binding: 0.00 seconds

  Total number of flip-flops in function min_max_rust_idiomatic: 193
  Total cycles             : 20 cycles
  Number of executions     : 2
  Average execution        : 10 cycles
----

.Idiomatic rust with `-O5` and `-C opt-level=3`
[%collapsible]
====
[source,console]
----
$ rustc --emit=llvm-ir --crate-type=lib src/min_max_rust_idiomatic.rs -o min_max_rust_idiomatic.ll -C overflow-checks=off -C no-vectorize-loops -C target-cpu=generic -C panic=abort -C opt-level=s
$ nix run github:zebreus/bachelor-thesis#bambu-appimage -- min_max_rust_idiomatic.ll --top-fname=min_max_rust_idiomatic --compiler=I386_CLANG12 --generate-tb=testbench_llvm.xml --simulate --simulator=VERILATOR -Os
  Module binding information for function min_max_rust_idiomatic:
    Number of modules instantiated: 98
    Number of performance conflicts: 6
    Estimated resources area (no Muxes and address logic): 861
    Estimated area of MUX21: 69
    Total estimated area: 930
    Estimated number of DSPs: 0
  Time to perform module binding: 0.01 seconds

  Total number of flip-flops in function min_max_rust_idiomatic: 961
  Total cycles             : 20 cycles
  Number of executions     : 2
  Average execution        : 10 cycles
----