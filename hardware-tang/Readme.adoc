= First steps with the tang nano 9k
:cpp: C++
:imagesdir: images


In this example we first want to get familiar with the tang nano 9k board by deploying a simple blinker/counter. We will write this counter in Verilog.

Then we want to try using bambu to synthesize a counter from {cpp}. We try to get the same interface as the reference counter we wrote earlier. In the best case we do not need to write any verilog code for the bambu example, but I am not sure whether bambu can generate a interface that can be used as the top level function from our {cpp} code.

== Reference counter in Verilog

=== Toolchain

The first step is to get the toolchain up and running.

Our toolchain is based on yosys, nextpnr and apycula.

.Makefile for deploying the counter to the tang nano 9k
[source,Makefile]
----
include::Makefile[tag=!bambu]
----

Running `make prog` synthesizes the `counter.v` file and programs it to the tang nano 9k. Seems to work.

We also create a `tangnano.cst` file that defines the pinout of the tang nano 9k. This is used by nextpnr to place the logic on the board.

.Content of `tangnano.cst`
[%collapsible]
====
.tangnano.cst
[source,cst]
----
include::tangnano.cst[]
----
====

=== Creating the counter

The counter is quite trivial and is lifted from a tutorial on the tang nano 9k.

.Interface of the reference counter
[symbolator]
....
include::counter.v[]
....

.counter.v
[source,verilog]
----
include::counter.v[]
----

Running `make prog` synthesizes the counter and programs it to the tang nano 9k. Seems to work.

// Insert video here

== Using bambu

The next step is to replicate that in {cpp} using bambu. I think the two big challenges are to get the interface right and to keep some kind of state in the counter.

=== Adjusting the toolchain

We adjust the Makefile for processing {cpp} code with. First we add rules to synthesize the {cpp} code with bambu.

.Additional rules for bambu
[source,Makefile]
----
include::Makefile[tag=bambu]
----

Running `make something.v` will now look for a file `something.cpp` and synthesize it using bambu. 

---

We also want to test the generated verilog code. We use verilator for testing.

.Rules for verilator
[source,Makefile]
----
include::Makefile[tag=verilator]
----

This rule assumes that the entrypoint for a Verilog file will be named `something_sim_main.cpp`. It uses that and the Verilog file to generate a test executable. We can use `make obj_dir/Vsomething` to generate the test executable for `something.v` and execute it with `obj_dir/Vsomething`.

This rule also trust that our testbench will always generate a `.vcd` file with a matching name.

---

.Rules for {cpp}
[source,Makefile]
----
include::Makefile[tag=clang]
----

We also add rules to compile the {cpp} code to an executable, so that we can verify that our function works as expected. When compiling to a native executable we set the `TEST_CPP` macro, which we can use to add a `main` function to our {cpp} code, when we are creating a executable.

=== Trying to keep state

We will try to synthesize something that keeps state. As a minimal example we will define a {cpp} function that has a counter which gets incremented every time the function is called.

.state_test.cpp
[source,cpp]
----
include::state_test.cpp[]
----

We can verify that the function keeps internal state as expected by executing its main function.

.Output of our function
[source,cpp]
----
include::state_test.native.log[]
----

The output contains the expected increasing values, so our function should be fine.

We synthesize this using bambu and get the following interface:

.Interface of the reference counter
[symbolator]
....
include::state_test.v[]
....

The interface of the generated Verilog module looks about right, but we dont know, whether it actually keeps state. In the previous post we used the testing framework that is built into bambu, but I think that we can't use that here, because it can only test pure functions. Instead we will use verilator directly to test the generated Verilog code. Our testabench will run the function for 50 clock cycles and generate a `.vcd` file.

.Detailed testbench for the counter
[%collapsible]
====
.state_test_sim_main.cpp
[source,cpp]
----
include::state_test_sim_main.cpp[]
----
====

The generated trace does not look like we expected it to look:

.Behaviour with only clock pulses
[wavedrom]
....
include::state_test.wavejson[]
....

It seems like the counter is only incremented once. I suspect that the startport also needs to go high to start a function execution. Let's adjust the testbench to also pulse `start` every 3 clock cycles.

.Behaviour with clock and start pulses
[wavedrom]
....
include::state_test_b.wavejson[]
....

Ok, start seems to actually trigger a function execution. What is a bit irritating to me is that the done_port stays low the whole time. I would have expected it to go high for at least one clock cycle, when the function is done. Maybe reset needs to be high the whole time.

.Behaviour with clock and start pulses. Also reset is high the whole time.
[wavedrom]
....
include::state_test_c.wavejson[]
....

Now we get a pulse on the done port. It is not quite what I expected, as it goes high after the start pulse, and switches back to low after the result changed. I think that the done_port being high means that the function is not yet finished. I would have expected the reverse behaviour. But I guess that is just a matter of taste.

My expectations for how the interface works have been mostly wrong. I will now go find some documentation, so that we can get a better understanding of how the interface works.

The https://panda.dei.polimi.it/?page_id=555[Bambu tutorial] does not mention the exact behaviour of the interface.

I was not able to find any documentation for the interface, the following table show what I found out by testing.

.What I got by testing
[cols="1,2,2"]
|===
|Port |Info |Speculation

|`clock`
|Needs to cycle between high and low
|

|`reset`
|Needs to be high for the module to work. At least the done signal is only emitted, if it is high
|Maybe resets the module if pulled to low

|`start_port`
|The module will start executing, if this is high and the function is finished. Pinning this to high will cause the function to repeat.
| There could be a delay

|`done_port`
|Pulses high for one cycle, when the module is done.
|Idk how this behaves, if the module is instant

|`return_port`
|Contains the return value. Can contain random values during function execution.
|I think it contains the valid return value on the falling flank of the `done_port` pulse, but it could also be on the rising flank.

|===



// TODO: Finish section

== And now for something completely different

Now that we have a working counter, we can try to do something more interesting. I want to try to synthesize a function that computes a md5 hash. I think that should be a good test for the toolchain, as the logic is quite complex and it requires a medium sized array of number constants at runtime.


.Rust implementation of the md5 function
[source,rust]
....
include::../rust-md5/src/md5.rs[tag=md5-implementation]
....

The rust implementation is based on the pseudocode example from https://en.wikipedia.org/wiki/MD5#Pseudocode[wikipedia]. Note that this implementation can only process one block of data. This should be enough for our test.

We use rust unittests to verify that our implementation works as expected. When hashing an empty string, we expect the result to be `d41d8cd98f00b204e9800998ecf8427e`, when hashing the string `"a"` we expect the result to be `0cc175b9c0f1b6a831c399e269772661`.

.Unittest implementation
[%collapsible]
====
[source,rust]
----
include::../rust-md5/src/md5.rs[tag=md5-test]
----
====

The tests pass, so we can be sure that our implementation is correct.

We can now synthesize the function and verify that it works as expected. We will use the same testcases as before. This time we define them in a xml file for bambu. This way it can test our function directly when we are synthesizing it.

.Testbench for the md5 function
[source,xml]
....
include::test-md5.xml[]
....


The tests pass, so we can be sure that our function works as expected and bambu was able to synthesize it correctly.

.Verilog interface of the md5 module
[symbolator]
....
include::md5.v[]
....

The synthesized interface also looks sane, so we can attempt the next step and try to get the module loaded to the FPGA. Note that the memory lanes and addresses are 64 bit wide. We are able to instruct bambu to create 32 bit wide memory interfaces but 64 bit is the default.

We need to write a wrapper that connects the function to the rest of the system. Our module expects to be able to get the input data and write the output data via its memory related ports. I think it will be the easiest if we hardcode the data for the empty string. We can then verify the output of our module by activating the LEDs on the FPGA board once we got the correct result.

But first we should figure out how the memory works.

.What do we want to learn about memory access?
* What addresses are used for the message and result arguments?
* How does the module read from memory?
* How does the module write to memory?
* What do the memory related signals mean?

The first question is probably the easiest to answer. We can just inspect the trace of the simulation when the function is started.

.Argument inputs when starting the module
[wavedrom]
....
{signal: [
  {name: 'clock', wave: 'p...|..'},
  {name: 'start_port', wave: 'lhl.|hl', "node" : ".A...B."},
  {name: 'Pd458 (message)', wave: 'x3..|3.', data: ['40000000', '40000200']},
  {name: 'Pd459 (result)', wave: 'x3..|3.', data: ['40000100','40000300']}
],
edge   : ["A First testcase", "B Second testcase"],
config: { hscale: 2 }}
....

For the first testcase the message data starts at address `0x40000000` and the result data starts at address `0x40000100`. For the second testcase the message data starts at address `0x40000200` and the result data starts at address `0x40000300`.

Now we still need to figure out how the module reads from these addresses. Let's take a look at the first time 0x40000000 is read.

.Memory signals when reading a value
[wavedrom]
....
{signal: [
  {name: 'clock', wave: 'p...'},
  {name: 'Mout_we_ram', wave: '2...', data: ['0x0']},
  {name: 'Mout_oe_ram', wave: '232.', data: ['0x0','0x1','0x0']},
  {name: 'Mout_data_ram_size', wave: '232.', data: ['0x0', '0x20', '0x0']},
  {name: 'Mout_addr_ram', wave: '232.', data: ['0x0', '40000000', '0x0']},
  {name: 'M_Wdata_ram', wave: '2...', data: ['0000000000000000']},
  {name: 'M_Rdata_ram', wave: '2.32', data: ['0x0', '0000000000000080', '0x0']},
  {name: 'M_DataRdy', wave: '2...', data: ['0x0']},
],
config: { hscale: 3 }}
....

The reads seem to happen in two cycles.

In the first cycle the module sets `Mout_oe_ram` to `1` to enable the output of the memory data, to tell the memory that it wants to read a value. It also sets Mout_data_ram_size to `0x20` (decimal 32), because it will only read 32 bits. This matches our expectations because our message is passed in as an array of u32 values. `Mout_addr_ram` is set to `0x40000000` which is the address of the first message value.

In the second cycle these signals all return to 0. The input `M_Rdata_ram` then contains the value that was read from the memory. In this case it is `0x00000080` which is the first byte of the message.

Let's take a look at the first time data is written to the result.

.Memory signals when writing values
[wavedrom]
....
{signal: [
  {name: 'clock', wave: 'p...'},
  {name: 'Mout_we_ram', wave: '23.2', data: ['0x0','0x3','0x0']},
  {name: 'Mout_oe_ram', wave: '2...', data: ['0x0']},
  {name: 'Mout_data_ram_size', wave: '23.2', data: ['0x0', '0x820', '0x0']},
  {name: 'Mout_addr_ram', wave: '2332', data: ['0x0', '4000010440000100','4000010C40000108','0x0']},
  {name: 'M_Wdata_ram', wave: '2332', data: ['0x0..00', '04B2008FD981DD4','7E42F8EC980980E9','0x0..00']},
  {name: 'M_Rdata_ram', wave: '2...', data: ['0x0']},
  {name: 'M_DataRdy', wave: '23.2', data: ['0x0', '0x3', '0x0']},
],
config: { hscale: 3.5 }}
....

Here something interesting happens, as we can see that the module writes 128 bits to the memory in just two cycles. I would have assumed that it would write 32 bits per cycle in four cycles, as our result consists of four u32 values. Here it seems to write 64 bits per cycle in two cycles.

The first write cycle puts the data `04B2008FD981DD4` at address `4000010440000100`. I think what actually happens here is that this are two writes to two different addresses. If we treat the first 32 bit as one operation and the second 32 bit as another operation, we can see that the first operation writes `04B2008F` to address `40000104` and the second operation writes `FD981DD4` to address `40000100`. These are indeed the correct values at the correct addresses, as the expected result for the first testcase is `D41D8CD9 8F00B204 E9800998 ECF8427E`.

`Mout_data_ram_size` (12 bit wide) is set to `0x820` which is a weird value. My best guess for now is that the two least significant nibbles are 0x20, which signifies the size of a values as 32 bits. The remaining most significant nibbles is 0x8 which could mean that two values are written at once. It could also be the offset in nibbles for the second number. We should look for documentation on this.

`Mout_we_ram` is set to `0x3` which could mean that we are writing two values at once. This is also supported by the fact that we write 64 bits in two cycles.

We can summarize the memroy access as follows:

.How them memory is accessed
[cols="1,1,2,2"]
|===
|Port |Better name |Description

|`Mout_oe_ram`
|`readMemory`
|Set to 0x1 to get data from the memory on the next clock cycle

|`Mout_we_ram`
|`writeMemory`
|Set to 0x3 to write two values to memory. Maybe you have to wait for the `M_DataRdy` signal to be nonzero before writing the second value.

|`Mout_data_ram_size`
|`valueSize`
|12 bit integer. The lower two nibbles seem to contain the size of the values in bits. The upper nibble seems to contain the offset in nibbles for the second value, when accessing two values at once.

|`Mout_addr_ram`
|`memoryAddress`
|Memory will be accessed at this address.

|`M_Wdata_ram`
|`dataToWrite`
|Outputs the data that will be written to memory when `Mout_we_ram` is set.

|`M_Rdata_ram`
|`readData`
|Contains the data that was read from memory when `Mout_oe_ram` was set.

|`M_DataRdy`
|`memoryReady`
|Set when a write operation is finished. Does not seem to get set during a read operation.

|===

.New questions for later
* Does 0x3 on `Mout_we_ram` mean that two values are written simultaneously?
* Does 0x3 on `Mout_oe_ram` mean that two values are read simultaneously?
* What does 0x820 on `Mout_data_ram_size` mean?



It looks like two values are written simultaneously, utilizing the full bandwidth of the memory interface. 



The wrapper also needs to simulate the memory



