:doctype: book
:last-update-label!:
:imagesdir: images
:source-highlighter: rouge
:rouge-style: github
:toclevels: 2
:stem:
:toc: macro
:sectanchors:
:notitle:
:title-page: false
:stylesheet: Readme.css
:toclevels: 3

image::logo_hda.svg[role=logo]

[.university.text-center]
Darmstadt University of Applied Sciences

[.faculty.text-center]
Faculty of Computer Science

[discrete]
= Is High-level synthesis from Rust possible using existing tools?

[.description.text-center]
Submitted in partial fulfilment of the requirements for the degree of +
Bachelor of Science (B.Sc.)

[.presented-by.text-center]
by +
*Lennart Eichhorn* +
[small]+Matriculation number: 759253+ +


[.other-people]
First Examiner:: Prof. Dr. Stefan Rapp
Second Examiner:: Prof. Dr. Ronald Charles Moore

<<<

[discrete]
== Abstract

// A short summary of the contents in English of about one page. The following
// points should be addressed in particular:

// * Motivation: Why did this work come about? Why is the topic of the
// work interesting (for the general public)? The motivation should be
// abstracted as far as possible from the specific tasks that may be given
// by a company.
// * Content: What is the content of this thesis? What exactly is covered in
// the thesis? The methodology and working method should be briefly
// discussed here.
// * Results: What are the results of this work? A brief overview of the
// most important results as a teaser to read the complete thesis.

// [NOTE]
// ====
// A great guide by Kent Beck how to write good abstracts can be found here:

// <https://plg.uwaterloo.ca/~migod/research/beckOOPSLA.html>
// ====

<<<

toc::[]

<<<

// Start with section and part numbering
:sectnums:
:part-signifier: Part
:partnums:

= Thesis

== Introduction

The popularity of the Rust programming language is rising and it is one of the most loved new programming languages. It integrates modern tooling like standardized dependency management, testing, documentation generation, formatting and building. In the future, the adoption will probably increase further and it could replace {cpp} as the most common system programming language <<Bug22>>.
It is possible that Rust also provides benefits in domains other than systems programming. It has been shown that Rust can be used for other domains such as GPU programming, web development or logic programming <<Sah22>> <<Byc22>> <<Kyr22>>. This enables us to use some of the benefits of Rust <<Bug22>> <<Cos19>>.

This paper will explore how Rust can be used in the domain of FPGA firmware development. Usually, FPGA firmware is developed in a Hardware Description Language (HDL) such as Verilog or VHDL. In these languages, the programmer has to describe the hardware in detail. This is a low-level approach that can lead to efficient designs, but it is quite time-consuming <<Mil20>>. The rust-hdl project enables us to express hardware descriptions in Rust similar to traditional HDLs <<rusthdl>>. In addition to manually writing hardware descriptions in an HDL, it is also possible to use High-level synthesis (HLS) to generate hardware descriptions in HDLs from an algorithmic description written in high-level programming languages. This provides increased productivity at the cost of slightly less optimized designs <<Mil20>>. This process is currently mostly used with C or {cpp} because they are the most common system programming languages. There are multiple HLS tools available that can synthesize HDL code from {cpp} code. Multiple of these tools are based around the LLVM compiler infrastructure <<Nan16>>. There is one reported use of Rust as an HLS language but that is of no use to us as their tools are not available <<Har22>>. As Rust is also based on LLVM, it is possible that it can be used with these tools too. 

To figure out whether Rust can be used as a source language for HLS, we searched for HLS tools that can be used for Rust. We developed a modular process for integrating HLS tools with rust-hdl <<rusthdl>>. We used this process to implement a proof-of-concept integration with the PandA Bambu HLS framework and showed that it is possible to use Rust as a source language for HLS. We also evaluated the resulting solution by synthesizing a simple example. We found that the solution is not yet suitable for production use, but that it is a promising starting point for further development.

// What exactly is the problem
// Why is this a problem

== How is hardware design done today

It is assumed that you have some knowledge of the Rust programming language and systems programming. This section will provide an overview about the topics that are relevant for this paper. It will also provide an overview about the related work that has been done for HLS from Rust.

=== Target platforms

There are two target platforms for logic design: field-programmable gate arrays (FPGA) and application specific integrated circuits (ASIC).

==== What is an FPGA

//TODO: Citations
// TODO: Idk if the intro is appropriate
CPUs process their instructions one by one. They are purpose-built machines that are carefully designed for processing lots of instructions in sequence. Traditional programming languages reflect this design for the most part. They are designed to make it easy for humans to write programs that can be executed sequentially one instruction at a time. There are approaches to parallelism, but they are either limited to having multiple threads of execution that run from top to bottom simultaneously. Or they have some instructions that perform the same operation on a fixed amount of data elements at the same time.


// TODO: citation needed
Field programmable gate arrays (FPGAs) are not designed to process instructions. As the name field programmable gate array implies, they consist of programmable logic gates with programmable connections between them. So while a CPU is a circuit designed to do one thing, an FPGA is a circuit designed to emulate other circuits. 

// TODO: FPGA 

// An FPGA can be used to emulate a CPU.
// TODO: citation needed
For example, a design describing the logic gates and connections that make up a CPU can be programed to the FPGA, so it will behave exactly like the CPU and can process instructions. Such a 'soft' CPU will be much bigger and therefore slower than a real CPU because a circuit emulated on an FPGA takes up more space than an application-specific circuit. This is however really useful for prototyping because you can test the CPU design in hardware with external peripherals, like memory and I/O devices.

// More details on using FPGAs for hardware development
// TODO: citation needed
In the past, FPGAs were mostly used like this for prototyping hardware development. Programmers designed a circuit in a hardware description language (HDL) and simulate it as a first stage of verification. If that worked it can be deployed to an FPGA, and get tested there. If everything works as expected the design can be taped out and manufactured as an ASIC.

// FPGA as computational accelerators
// TODO: citation needed
This is still the most common use case for FPGAs, but it is not the only one. In recent years the usage of FPGAs as pseudo-general-purpose computational accelerators became more relevant. Here you do not use them to prototype circuits that will eventually be taped out but as the final platform. FPGAs used in this context are known as _computational FPGAs_. It is somewhat comparable to the use of GPUs as computing accelerators. But where GPUs excel at tasks that perform the same operations in parallel on massive amounts of data, FPGAs can be used for some kind of computations with irregular parallelism with static structure. In opposition to GPUs, it is not yet clear what an appropriate abstraction for the computational pattern used with computational FPGAs is.

==== What is an ASIC



=== Accelerator design vs logic design



=== Netlists are synthesized to hardware

// TODO: This is a stub
All approaches of hardware design end up generating a structural gate-level description called netlist typically in a subste SystemVerilog. This netlist is then used to generate the actual hardware design in a mostly automated fashion. How this step actually works depends on what kind of Hardware is targeted e.g. FPGA, ASIC or fully custom chips.
//<<Fla20>>

This step is basically manufacturing a design. The focus of this paper is only on design and not on manufacturing, so we will not go into detail about this step. It is just important to know that a netlist is something that can be manufactured / deployed to a FPGA.

=== Design using traditional Hardware Description Languages
// What are common HDLs and what are they used for
// TODO: Systema verilog is most common nowadays
Traditionally, logic design is done in hardware description languages (HDL). There are two established ones, Verilog and VHDL. VHDL has a slightly higher level of abstraction and some features that make it easier to manage bigger projects. In some ways, the relation between Verilog and VHDL is comparable to the relation between C and {cpp} in terms of features and abstraction. Both can be used to model the structure of hardware equally efficiently, so the choice is mostly a matter of personal preference. <<Smi96>>

// TODO: Mention timing

// What do you describe in HDLs
// TODO: Citation needed
Most commonly HDLs are used to describe circuits in a register-transfer level (RTL) abstraction. On RTL these languages describe registers that can hold state and the combinational (time-independent) logic that connects them. In HDLs the registers and combinational logic can be bundled into a module to make it reusable. These modules can then be connected to form a larger circuit. This is the basic structure of an HDL design.

// What distinguishes them from progamming languages

// What is a typical HDL design flow
A typical HDL design flow consists of four phases, design, verification, synthesis and implementation. In the design phase, the circuit is designed in an HDL. The design is then verified in various ways. To verify the behaviour of a design testbenches are defined. These testbenches (usually also written in HDL) instantiate the module of the design under test (DUT), exercise the inputs and verify that the outputs behave as expected. A logic simulator is used to execute the testbenches. This is comparable to unittesting in programming languages. After the design is verified, a logic synthesis tool is used to synthesize the design into a optimized gate-level logic description (netlist). A formal equivalence tool can then be used to verify that the netlist is equivalent to the original design. In the implementation phase, the netlist is mapped to the target hardware. <<Fla20>>
 
// What are the problems with HDLs
The use of HDLs is mostly limited to hardware engineers

// What are the possible solutions

==== SystemVerilog sample

=== Design using alternative Hardware description languages

There are multiple modern HDLs that try to improve on the shortcomings of Verilog and VHDL. Most of them try to bring some features from modern programming languages to hardware design. (linting, formatting, dependency management, namespaces/scoping, better support for multifile projects, ...). These languages are usually transpiled to Verilog and then synthesized to netlists.

==== Chisel

// TODO: This is a stub
Probably the most popular alternative HDL. It is a Scala DSL that is transpiled to Verilog.

==== rust-hdl

// TODO: This is a stub
rust-hdl is a Rust project that allows writing RTL logic in Rust and generates Verilog from it. In rust-hdl the interfaces and registers of Verilog modules are defined as a structs. The internal logic is defined in an update function which is called on every clock pulse. This is similar to the way that HDLs work. <<rusthdl>>

//TODO: Test if this compiles
.Full adder written in Verilog
[source,verilog]
----
module blink (clock, led);
  input clock;
  output led;

  reg [31:0] counter = 32'0;
  reg led_status = 0;

  always @(posedge clock) begin
    counter <= counter + 1;
    if (counter > 1000) begin
      led_status <= !led_status;
      counter <= 32'0;
    end
  end

  assign led = led_status;
endmodule 
----

//TODO: Test if this compiles
.Full adder written in rust-hdl
[source,rust]
----
#[derive(LogicBlock)]
struct Blinker {
    pub clock: Signal<In, Clock>,
    pub led: Signal<Out, bool>,
    counter: DFF<Bits<32>>,
    led_status: DFF<bool>,
    delay: Constant<Bits<32>>,
}

impl Blinker {
    pub fn new(delay: u32) -> Self {
        Self {
            clock: Default::default(),
            led: Default::default(),
            counter: Default::default(),
            delay: Constant::new(delay.into()),
        }
    }
}

impl Logic for Blinker {
    #[hdl_gen]
    fn update(&mut self) {
        self.counter.clock.next = self.clock.val();
        self.counter.d.next = self.counter.q.val() + 1u32.to_bits();

        self.led.next = self.led_status.q.val();

        if self.counter.q.val() > self.delay.val() - 1 {
            self.counter.d.next = 0.into();
            self.led_status.d.next = ! self.led_status.q.val();
        }
    }
}
----

The `update` defines the internal logic of the module. The function sets the values of all output ports of the module based on the input ports. The rust-hdl library enforces that a value is assigned to every port at compiletime. If there are multiple assignments to a port the last one is valid. 

// TODO: List limitations of the update function
As the update function represents combinational logic, only a small subset of Rust is allowed in it.

As rust-hdl Code is just normal Rust code all of the features of the Rust ecosystem can be used. A rust-hdl project can for example be verified using the unit testing framework integrated into Rust. It can also use Rusts build system and package manager cargo. It is also possible to publish rust-hdl libraries to the rust package registry. <<rusthdl>>


=== Design using High-level synthesis
// What is HLS
High-level synthesis (HLS) is a process that can generate a HDL specification of a circuit from a description in a high-level programming language. This description is usually written in a high-level programming language such as C or {cpp}. This is a more productive approach than writing HDL code directly, but the resulting designs are less efficient. The generated HDL code can then be used in the same way as manually written HDL code. <<Mil20>> <<Nan16>>

HLS tools can be distingushed into two major categories. Those that accept a general purpose language and those that accept a domain specific language (DSL) a an input. Using a DSL as input can lead to better performing designs, but it also raises challenges for adoption. A general purpose language makes it easier for the algorithm designer, who is usually a software developer, to write code. <<Nan16>> 

// TODO: This is a stub
A special category of DSLs for HLS are accelerator design languages (ADL).

// What HLS tools are there
// TODO: Add citation for vivado
// TODO: Add citation for usually.
// TODO: Add citation for bambu is the biggest. 
HLS tools are usually available as a part of the IDE provided by the FPGA vendors. For example, AMD Xilinx provides the Vivado HLS tool as part of its IDE and Intel Altera includes the Intel HLS Compiler in its Quartus Prime IDE. <<intel-hls>> There are also a few open-source HLS tools available. The biggest open-source HLS tool that is currenlty activly maintained is panda bambu.  <<Nan16>> 

bambu provides as a research environment to experiment with new ideas in HLS. It can take C/C++ and LLVM IR as input. <<Fer21>>

In this paper we will use bambu as a HLS tool, because it is open-source and supports the latest LLVM version. 

// What does HLS generate. Specifically bambu
// TODO: This is a stub
// The modules generated with HLS tools are usually some kind of state-machine. In the case of panda-bambu These modules have a clock input that can be used to proceed to the next state and a output that indicates that the state-machine is done.

// What are the problems with those languages
// TODO: This section does probably not belong in this part
Old programming languages, we have better alternatives nowadays
More steps in the design flow

// ==== Bambu HLS



=== Design using accelerator design languages

Accelerator design languages (ADL) are a family of programming languages that are specifically designed to be synthesized to HDL. They are mostly similar to programming languages but offer many features that are usually only found in HDLs, like more fine-grained control over timing and memories memory access. <<hdl-to-adl>>

== Concept, implementation and architecture

// Short overview of the solution and this section
The goal of this paper is to use Rust as a source language for HLS using an existing HLS tool. First a suitable toolchain has to be designed. Then a process for integrating the toolchain with a HDL has to be developed. Finally, a proof-of-concept implementation will be done to show that the process works and enable evaluation of the resulting solution.

// TODO: Maybe define some criteria for our solution
// * Can synthesize a simple Rust program
// * Can synthesize our md5 implementation
// * Can synthesize most stateless Rust function
// * The synthesized function can use Rust crates from crates.io
// * The existing Rust tooling (linter, formatter, etc.) work with out function

=== Toolchain for synthesizing Rust

As there is currently no tool that can synthesize Rust directly the first step in our toolchain needs to convert the Rust code into a language that can be used by an existing HLS tool. There are multiple HLS tools that support C or {cpp} by using LLVM compiler infrastructure. As a result of using LLVM some of these tools can also use LLVMs intermediate representation (LLVM IR) directly as an input language. <<Nan16>> The Rust compiler can compile Rust code to LLVM IR, so this is a good starting point for our toolchain.

The Rust compiler is frequently updated and the generated LLVM IR usually uses the latest LLVM version. This means that a suited HLS tool needs to be activly maintained to support the generated LLVM IR. The only HLS tool that fulfills these requirements seems to be panda bambu. SmartHLS and Vivado HLS may also be capable of operating on LLVM IR, but they are not open source and only available as part of an IDE and not as standalone programs, which makes them unsuitable for our use case.

.The toolchain
[pikchr]
....
   arrow right 150% "Rust" "Source"
   box rad 10px "Rust Compiler" "Compiler" "(rustc)" fit
   arrow right 190% "LLVM IR" "Intermediate"
   box rad 10px "PandA Bambu" "HLS Synthesizer" "(bambu)" fit
   arrow right 130% "Verilog" "RTL"
....

=== Integrating the toolchain with rust-hdl

//TODO: This is a stub
Being able to synthesize Rust to Verilog in a vacuum is not that usefull. We should be able to use it in a larger HDL design. This paper will use rust-hdl as a HDL. This way the HDL design can be completly written in Rust.

The generated Verilog is wrapped in a rust-hdl module. Rust-hdl is not able to simulate embedded verilog, so we use Verilator to build a library that can be used to simulate the generated Verilog and link the rust program against it.

This also allows us to perform verification directly in rust unit tests. Nice integrated development experience.

Challenge: integrating bambu

//TODO: diagram of the integrated toolchain


=== Proof-of-concept implementation

// TODO: This is a stub
The proof-of-concept implementation uses a Rust procedural macros to transform a Rust function into a rust-hdl module.

// TODO: Show of an example

==== Explain neccessary compiler flags


== Experiments and results

=== Show limitations of the synthesizable subset of Rust

Show the limitations of the toolchain. Limitations of the synthesizable subset of Rust.

=== Show how the Rust ecosystem can be used

=== Generated modules

Take a look at the generated modules

=== Performance compared to HLS from {cpp}

Compare performance against {cpp}. basically the same as in first-toolchain.adoc


// Perform experiments and collect data about our solution

== Discussion and evaluation of the experiments


Discuss limitations

Discuss the results of the performance experiments

Discuss compiler flags? 

// Why is this a solution
// Discuss the results of the experiments

== Conclusion and future work
// TODO: This is a stub
// This is completely written by copilot and should be rewritten by hand
In general the toolchain is working quite well. HLS from Rust is definitly possible with little restrictions. The performance of the generated modules is also quite good. The generated modules are not as good as hand written modules, but they are good enough for most applications. The generated modules are also quite large, but this is not a problem for most applications.

// TODO: This is a stub
// This is completely written by copilot and should be rewritten by hand
The toolchain is also quite easy to use. The only thing that needs to be done is to add a procedural macro to the function that should be synthesized. This is a very simple change and does not require any changes to the function itself. The procedural macro can also be used to add additional information to the function that can be used by the HLS tool. This is very useful for example to specify the clock frequency of the function.


[glossary]
== List of abbreviations
// Abbreviations from here will automatically be linked into the document

// Abbreviations in a random order and links to read more about them
[glossary]
[[FPGA]]FPGA:: Field-programmable gate array https://en.wikipedia.org/wiki/Field-programmable_gate_array[🔗^]
[[HLS]]HLS:: High-level synthesis https://en.wikipedia.org/wiki/High-level_synthesis[🔗^]
[[HDL]]HDL:: Hardware description language https://en.wikipedia.org/wiki/Hardware_description_language[🔗^]
[[ADL]]ADL:: Accelerator design language https://www.sigarch.org/hdl-to-adl/[🔗^]
[[GPU]]GPU:: Graphics processing unit https://en.wikipedia.org/wiki/Graphics_processing_unit[🔗^]
[[LLVM_IR]]LLVM IR:: LLVM intermediate representation https://en.wikipedia.org/wiki/LLVM#Intermediate_representation[🔗^]
[[RTL]]RTL:: Register-transfer level https://en.wikipedia.org/wiki/Register-transfer_level[🔗^]
[[DUT]]DUT:: Design/Device under test https://en.wikipedia.org/wiki/Test_bench[🔗^]

[bibliography]
== References

// Claims to have a transpiler from a subset of Rust (RAR) to restriceted algrithmic C (RAC) that can be synthesized to FPGA. No source.
// The first paper to mention HLS from Rust. 
* [[[Har22]]]
Hardin, David,
_Hardware/Software Co-Assurance using the Rust Programming Language and ACL2_,
arXiv preprint arXiv:2205.11709,
2022.
https://arxiv.org/abs/2205.11709v1[🔗^]

* [[[Rog20]]]
Rogers, Samuel and Slycord, Joshua and Baharani, Mohammadreza and Tabkhi, Hamed,
_gem5-SALAM: A System Architecture for LLVM-based Accelerator Modeling_,
2020 53rd Annual IEEE/ACM International Symposium on Microarchitecture (MICRO), 471-482,
2020.
https://ieeexplore.ieee.org/abstract/document/9251937[🔗^]

* [[[Li21]]]
Li, Rui and Berkley, Lincoln and Yang, Yihang and Manohar, Rajit,
_Fluid: An Asynchronous High-level Synthesis Tool for Complex Program Structures_,
2021 27th IEEE International Symposium on Asynchronous Circuits and Systems (ASYNC), 1-8,
2020.
https://ieeexplore.ieee.org/abstract/document/9565447[🔗^]

* [[[Lia23]]]
Liang, Geng-Ming and Yuan, Chuan-Yue and Yuan, Meng-Shiun and Chen, Tai-Liang and Chen, Kuan-Hsun and Lee, Jenq-Kuen,
_The Support of MLIR HLS Adaptor for LLVM IR_,
Workshop Proceedings of the 51st International Conference on Parallel Processing, 1-8,
2020.
https://doi.org/10.1145/3547276.3548515[🔗^]

* [[[Fer21]]]
+F. Ferrandi et al.+,
_Invited: Bambu: an Open-Source Research Framework for the High-Level Synthesis of Complex Applications_,
2021 58th ACM/IEEE Design Automation Conference (DAC), 1327-1330,
2021.
https://ieeexplore.ieee.org/abstract/document/9586110[🔗^]
https://re.public.polimi.it/retrieve/668507/dac21_bambu.pdf[📁^]

* [[[Rot10]]]
+Nadav Rotem,+
_C-to-Verilog. com: High-Level Synthesis Using LLVM_,
University of Haifa,
2010.
https://llvm.org/devmtg/2010-11/Rotem-CToVerilog.pdf[🔗^]

* [[[Sch20]]]
Fabian Schuiki, Andreas Kurth, Tobias Grosser, and Luca Benini,
_LLHD: a multi-level intermediate representation for hardware description languages_,
In Proceedings of the 41st ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI 2020), 258-271,
2020.
https://doi.org/10.1145/3385412.3386024[🔗^]

// Multiple HLS tools use LLVM
// C/Cpp are most popular languages for HLS
* [[[Nan16]]]
+R. Nane et al.+,
_A Survey and Evaluation of FPGA High-Level Synthesis Tools_,
IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems, 1591-1604,
2016.
https://ieeexplore.ieee.org/abstract/document/7368920[🔗^]
https://sci-hub.st/10.1109/tcad.2015.2513673[📁^]

* [[[Nor18]]]
+D. H. Noronha, B. Salehpour and S. J. E. Wilton+,
_LeFlow: Enabling Flexible FPGA High-Level Synthesis of Tensorflow Deep Neural Networks_,
Fifth International Workshop on FPGAs for Software Programmers, 1-8,
2018.
https://ieeexplore.ieee.org/abstract/document/8470462[🔗^]

* [[[Soz22]]]
Sozzo, Emanuele Del, et al.,
_Pushing the level of abstraction of digital system design: A survey on how to program FPGAs_,
ACM Computing Surveys, 1-48,
2022.
https://dl.acm.org/doi/abs/10.1145/3532989[🔗^]

* [[[XLS]]]
_XLS project page_
https://google.github.io/xls/[🔗^]

* [[[DSLX]]]
_DSLX Reference_
https://google.github.io/xls/dslx_reference/[🔗^]

* [[[rusthdl]]]
_rust-hdl project overview_
https://github.com/samitbasu/rust-hdl[🔗^]


* [[[Zen12]]]
_Identifying Barriers to Adoption for Rust through Online Discourse_
https://arxiv.org/pdf/1901.01001.pdf[🔗^]

* [[[so-trends]]]
_Stack Overflow Trends_
https://insights.stackoverflow.com/trends?tags=rust%2Cc%2B%2B

// Rust has an ecosystem that greatly simplifies any software projec
// Rust is great
* [[[Bug22]]]
+William Bugden, Ayman Alahmar+,
_Rust: The Programming Language for Safety and Performance_,
asXiv,
2022.
https://arxiv.org/pdf/2206.05503.pdf[🔗^]

// Rust can be used for GPU programming
* [[[Byc22]]]
+Andrey Bychkov, Vsevolod Nikolskiy+,
_Rust Language for GPU Programming_,
In: Voevodin, V., Sobolev, S., Yakobovskiy, M., Shagaliev, R. (eds) Supercomputing. RuSCDays 2022. Lecture Notes in Computer Science, vol 13708. Springer, Cham, 2022, pp. 522-32,
2022
https://doi.org/10.1007/978-3-031-22941-1_38[🔗^]

// Rust can be used for web programming
* [[[Kyr22]]]
+Kyriakou K-ID, Tselikas ND+,
_Complementing JavaScript in High-Performance Node.js and Web Applications with Rust and WebAssembly._,
Electronics 11, no. 19: 3217,
2022
https://doi.org/10.3390/electronics11193217[🔗^]

// Probably one of the greatest features of the language is the package manager, called cargo.
* [[[Cos19]]]
+Cosmin Cartas+,
_Rust - The Programming Language for Every Industry_,
ECONOMY INFORMATICS JOURNAL, 19, 45-51,
2019
https://doi.org/10.12948/ei2019.01.05[🔗^]

// state-of-art bottom-up logic programming within the Rust ecosystem
* [[[Sah22]]]
+Arash Sahebolamri, Thomas Gilray, Kristopher Micinski+,
_Seamless Deductive Inference via Macros_,
Proceedings of the 31st ACM SIGPLAN International Conference on Compiler Construction, 77-88,
2022
https://doi.org/10.1145/3497776.3517779[🔗^]

// Productivity in HLS is better than HDL
// HLS offers easier design and testing
// HDL implementation is better than HLS
* [[[Mil20]]]
+Roberto Millón, Emmanuel Frati, Enzo Rucci+,
_A Comparative Study between HLS and HDL on SoC for Image Processing Applications_,
Revista elektron, Vol. 4, No. 2, 100-106,
2020
https://doi.org/10.37537/rev.elektron.4.2.117.2020[🔗^]
http://elektron.fi.uba.ar/index.php/elektron/article/view/117/219[📁^]

// Describing the traditional HDL design flow (in 1996)
// TODO: Find newer source
* [[[Smi96]]]
+Douglas J. Smith+,
_VHDL & Verilog compared & contrasted—plus modeled example written in VHDL, Verilog and C._,
In Proceedings of the 33rd annual Design Automation Conference, pp. 771-776,
1996
https://dl.acm.org/doi/pdf/10.1145/240518.240664[🔗^]

// 
* [[[Fla20]]]
+Peter Flake, Phil Moorby, Steve Golson, Arturo Salz, and Simon J. Davidmann+,
_Verilog HDL and its ancestors and descendants._,
Proc. ACM Program. Lang. 4, no. HOPL (2020): 87-1,
2020
https://www.researchgate.net/profile/Arturo-Salz-2/publication/342137214_Verilog_HDL_and_its_ancestors_and_descendants/links/613fc7b45d9d0e131b427dbb/Verilog-HDL-and-its-ancestors-and-descendants.pdf[🔗^]

* [[[intel-hls]]]
_Intel® High Level Synthesis Compiler_
https://www.intel.de/content/www/de/de/software/programmable/quartus-prime/hls-compiler.html

* [[[hdl-to-adl]]]
_From Hardware Description Languages to Accelerator Design Languages_
https://www.sigarch.org/hdl-to-adl/
// Shows that HLS is twice as fast as HDL 
// M. Pelcat, C. Bourrasset, L. Maggiani and F. Berry, "Design productivity of a high level synthesis compiler versus HDL," 2016 International Conference on Embedded Computer Systems: Architectures, Modeling and Simulation (SAMOS), Agios Konstantinos, Greece, 2016, pp. 140-147, doi: 10.1109/SAMOS.2016.7818341.
// https://ieeexplore.ieee.org/abstract/document/7818341


// Reference thesis:
// * https://webthesis.biblio.polito.it/7573/1/tesi.pdf
// * https://scholarworks.gvsu.edu/cgi/viewcontent.cgi?article=1754&context=theses

include::styles/trailing-scripts.adoc[]
