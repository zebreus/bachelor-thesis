use std::path::{Component, PathBuf};

use crate::buildscript_hls::find_modules::MacroModule;

use itertools::Itertools;
use thiserror::Error;

#[derive(Error, Debug)]
pub enum ExtractHashError {
    #[error("The output file {filename} already exists but does not look like it was generated by rust_hls")]
    GeneratedFileExistsButDoesNotContainAHash { filename: String },
}

pub fn extract_existing_hash_from_content(
    content: &String,
) -> Result<Option<String>, ExtractHashError> {
    let existing_file = std::fs::read_to_string(file).ok();
}

/// Converts a PathBuf into the parts of a module path.
///
/// Example: src/foo/bar.rs -> ["foo", "bar"]
pub fn extract_existing_hash(file: &PathBuf) -> Result<Option<String>, ExtractHashError> {
    let existing_file = std::fs::read_to_string(file).ok();
}

/// This function calculates information about the module path of a module.
///
/// Arguments:
/// * `source_file`: The path to the source file of the module. Relative to the crate root
/// * `module_path`: The path to the module inside the source file
/// * `function_name`: The name of the function that is being synthesized
pub fn get_module_path_information(
    source_file: &PathBuf,
    module_path: &String,
    function_name: &String,
) -> Result<ModulePathInformation, GetModulePathsError> {
    let module_path_to_file = file_to_module_path(&source_file)?;
    let module_path_in_file = module_path_string_to_vec(module_path.clone())?;
    let absolute_input_module_path = module_path_to_file
        .iter()
        .chain(module_path_in_file.iter())
        .map(|part| part.to_string())
        .collect::<Vec<String>>();

    let mut absolute_module_path = absolute_input_module_path.clone();
    let last_module = absolute_module_path.pop().unwrap_or("lib".into());
    absolute_module_path.push(format!("{last_module}_synthesized"));

    let input_file = source_file.clone();
    let output_file = PathBuf::from(format!(
        "src/{}.rs",
        absolute_module_path
            .iter()
            .map(|part| format!("{part}").to_string())
            .join("/")
    ));
    return Ok(ModulePathInformation {
        input_file,
        output_file,
        module_path_in_file,
        module_path_to_file,
        absolute_input_module_path,
        absolute_module_path,
    });
    // let
}
