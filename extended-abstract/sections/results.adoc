== Results
// _I have not yet conducted most of the experiments as described in the methodology, so the results section is mostly based on informal experimentation_
// TODO: Specify Rust version somewhere

A subset of Rust can be synthesized with existing HLS tools. PandA bambu appears to be the most suited HLS tool at the moment.

PandA bambu supports most of Rust with the exception being everything that has the potential to panic. This includes array accesses as Rust automatically generates bound checks for them. For most simple cases this issue can be mitigated by using a higher optimization level when compiling the Rust code to LLVM IR. This will enable the Rust compiler to remove panics if it can statically prove that they will never be executed. It is not guaranteed that the Rust compiler can detect that a panic, so it is not a general solution. If the Rust code contains no panics that cannot be removed by optimization the HLS nearly always works. The performance of the synthesized modules seems to be on par with the performance of an equivalent module synthesized from Cpp code.

== Discussion

There may be other closed source HLS tools that can be used to synthesize Rust via LLVM IR. None of them actively support LLVM IR but at least Xilinx vivado HLS uses clang as a frontend so it could be possible to use it to synthesize Rust. I have not yet tried this.

We focused on synthesizing Rust via LLVM IR, but there may be other somewhat viable paths to HLS. Another path could be to decompile a binary generated by the Rust compiler into C and use that as a source for HLS. This could make it possible to synthesize Rust with more HLS tools.

This paper focused only on using existing HLS tools and the Rust compiler. It is difficult to get the Rust compiler to generate LLVM IR that is compatible with the HLS tools. There are multiple ways how additional custom tools could improve the process. It could be useful to write some custom LLVM passes that make the generated LLVM IR more compatible with the HLS tools. A custom LLVM pass could also be used to replace panics that cannot be removed by optimization with something that can be synthesized. A modified version of the Rust compiler including a llvm target that includes these custom LLVM passes could also be useful. Another approach could be to modify PandA bambu to improve support for LLVM IR generated by the Rust compiler. There are more ways to improve the process by adding custom tools. A lot of the problems we encountered could be solved by writing a custom HLS tool in Rust.

// Modern FPGAs usually have some form of buildin modules for specific operations <<citation?>>. We did not investigate if our generated modules use these buildin module?