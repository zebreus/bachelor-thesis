== Methodology

=== Finding candidates for HLS tools

We indentified HLS tools that have potential to be used for Rust, by searching google scholar, github, and google. Another criteria for the search was that the tool is open source, so that we are able to adjust it if necessary. First we searched for HLS tools that support Rust directly. That search did not yield any results. The Rust compiler supports compiling Rust code to LLVM intermediate representation (IR). We then considered HLS tools which support LLVM IR as an input language. The potential HLS tools also should have ongoing development, as the Rust compiler generates the latest LLVM IR version. PandA Bambu was the only tool meeting all three criteria. Excluding the acive development criteria, an older version of LegUp or ahaHLS could be considered as well. Excluding the open source criteria, there may be other HLS tools that support LLVM IR but we were not able to verify that.

=== Evaluating a HLS tool

To evaluate a HLS tool, we need to define a set of criteria. As our focus is on the integration of HLS tools with Rust our main criteria is the supported subset of Rust and reliability. The quality of the synthesized result is also evaluated.

The supported subset of Rust is evaluated by trying to synthesize a set of Rust functions. The functions are chosen to cover the most common Rust features. The functions are then synthesized with the HLS tool. If the synthesis is successful it is evaluated that the generated module is also correct.

We evaluate the reliability of a HLS tool for Rust by trying to synthesize multiple Rust functions that only use the supported subset of Rust for a given HLS tool. A tool with perfect reliability would be able to synthesize all functions. A tool with poor reliability would require additional tweaking with the exact structure of the function or with the options used for the HLS tool on a per-function basis.

We evaluate the performance of a HLS tool for Rust by comparing the module synthesized from Rust with a module synthesized from the preferred input language of the HLS tool. The performance is evaluated by comparing the execution time and the number of LUTs of the modules.
// Currently I am not sure how we can measure these two metrics n a standardized way across multiple tools.

// TODO: Find out in which section this belongs
=== Reusable toolchain

We created a modular toolchain for integrating HLS frameworks with rust-hdl. We choose this over working directly with the HLS frameworks as it allows for faster iterations and easier integration of other HLS frameworks. We centered our experiments around rust-hdl to minimize the complexity of needing to manage multiple languages in our experimental setups. The whole process is automated in a single Rust macro so that it allows for faster iterations.

The first step extracts functions marked with a `#[hls]` attribute macro into separate Rust crates.  The extracted crates contain the same dependencies and code as the source crate. The crate type is changed to a library crate, the `#[hls]` attribute is removed and it is adjusted to only export the marked function. It is also ensured that the marked function has an interface that is fitting for HLS. If the `#[hls]` macro for a specific function contains additional parameters, a file containing these parameters is also created in the extracted crate directory. The parameters can be used to pass additional configuration to the HLS tool.

// TODO: A build script is generated and then executed
In the second step a High-level synthesis tool is used to synthesize the extracted crates into Verilog. First we use the Rust compiler to compile an extracted crate into a single LLVM IR file. Then the highlevel synthesis tool generates verilog code for the marked functions and their dependencies. The generated verilog code is place in the extracted crate's `target` directory. This step can be adapted to use other HLS tools. We choose PandA bambu for this step as it is easily available, well-documented and supports LLVM IR input. This step can be easily adjusted for other HLS tools.

The generated Verilog is then wrapped in rust-hdl and embedded into the original Rust project. The wrapping process first extracts the interface of the generated Verilog module. It then creates a rust-hdl module with the same interface. The Verilog code is then placed in the module's body. The wrapped module is then inserted at the original location of the marked function.

// Possible test functions:
// * Sine wave generator: A simple sine wave generator that is used to validate the basic functionality of the HLS tool.
// * FIR filter: A FIR filter used to evaluate the performance of the HLS tool.
// * Matrix multiplication: A matrix multiplication algorithm used to evaluate the performance of the HLS tool.
// * Viterbi decoder: A Viterbi decoder used to evaluate the performance of the HLS tool.
// * Sort: A sort algorithm used to evaluate the performance of the HLS tool.
// * Image processing: A image processing algorithm used to evaluate the performance of the HLS tool.
// * AES: A AES algorithm used to evaluate the performance of the HLS tool.